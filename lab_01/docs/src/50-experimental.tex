\chapter{Экспериментальная часть}

    В данном разделе будет проведено функциональное тестирование разработанного программного обеспечения. Так же будет произведено измерение временных характеристик и характеристик по памяти каждого из реализованных алгоритмов.

    \section{Технические характеристики}
    
        Технические характеристики устройства, на котором выполнялось исследование:
        
        \begin{itemize}
            \item Процессор: Intel(R) Core(TM) i5-8250U CPU @ 1.60GHz \cite{intel}
            \item Оперативная память: 8 Gb
            \item Операционная система: elementary OS 6 Odin \cite{elemos}
        \end{itemize}
    
    \section{Тестирование}
    
        Юнит тестирование проводилось при помощи фрэймворка GoogleTests. Были выполнены следующие тесты
        
        \begin{table}[]
            \centering
            \caption{Функциональные тесты}
            \begin{tabular}{|c|c|c|c|}
\hline \textbf{Строка 1} & \textbf{Строка 2} & \textbf{Левенштейн} & \textbf{Дамерау-Левенштейн}  \\
\hline CONNECT & CONEHEAD & 4 &  \\
\hline & CONEHEAD & 8 & 8 \\
\hline &  & 0 & 0 \\
\hline deniska & deniska & 0 & 0 \\
\hline abc & bc & 1 & 1 \\
\hline abc & ac & 1 & 1 \\
\hline abc & ab & 1 & 1 \\
\hline abc & xbc & 1 & 1 \\
\hline abc & axc & 1 & 1 \\
\hline abc & abx & 1 & 1 \\
\hline CONNECT & CNNNETC &  & 2 \\
\hline abcd & badc &  & 2 \\
\hline
            \end{tabular}
            \label{tab:my_label}
        \end{table}
        
        
        При проведении функционального тестирования, полученные результаты работы программы совпали с ожидаемыми. Таким образом, функциональное тестирование пройдено успешно.
    
    \section{Временные характеристики}
    
        Результаты замеров по результатам экспериментов приведены в Таблице \ref{tab:time}. В данной таблице для значений, для которых тестирование не выполнялось, в поле результата находится ” - ”.
    
        \begin{table}[]
            \centering
            \caption{Замер времени для строк разной длины}
            \resizebox{\columnwidth}{!}{% 
            \begin{tabular}{|c|c|c|c|c|}
\hline \multirow{3}{*}{\textbf{Длина строк}} & \multicolumn{4}{c|}{\textbf{Время, сек}} \\
\cline{2-5} & \multicolumn{2}{c|}{\textbf{Левенштейн}} & \multicolumn{2}{c|}{\textbf{Дамерау-Левенштейн}} \\
\cline{2-5} & \textbf{Рекурсивный} & \textbf{Итеративный} & \textbf{Рекурсивный} & \textbf{Итеративный} \\
\hline    1 &   3e-08 & 5.3e-08 & 3.6e-08 & 6.6e-08 \\
\hline    2 & 6.7e-05 & 3.1e-07 & 6.6e-05 & 3.8e-07 \\
\hline    4 & 8.1e-05 & 3.2e-07 & 6.6e-05 & 3.8e-07 \\
\hline    6 & 6.6e-04 & 4.2e-07 & 6.5e-05 & 3.8e-07 \\
\hline    8 &  0.0019 & 5.2e-07 &   0.002 & 6.7e-07 \\
\hline   16 &       - &   2e-06 &       - & 2.7e-06 \\
\hline   32 &       - & 8.8e-06 &       - & 1.3e-05 \\
\hline   64 &       - & 3.5e-05 &       - & 4.4e-05 \\
\hline  128 &       - & 0.00012 &       - & 0.00016 \\
\hline  256 &       - & 0.00048 &       - & 0.00064 \\
\hline  512 &       - &  0.0019 &       - &  0.0025 \\
\hline 1024 &       - &  0.0075 &       - &    0.01 \\
\hline
            \end{tabular}%
            }
            \label{tab:time}
        \end{table}
    
   Отдельно сравним итеративные алгоритмы поиска расстояний Левенштейна и Дамерау– Левенштейна. Сравнение будет производится на основе данных, представленных в Таблице \ref{tab:time}. Результат можно увидеть на Рисунке \ref{plt:time_cmp_l_dl}. 
        
    \begin{figure}[!h]
      \centering
      \begin{tikzpicture}
        \begin{axis}[
          axis lines=left,
          xlabel=Длина строк,
          ylabel={Время, мс},
          legend pos=north west,
          ymajorgrids=true
        ]
          \addplot table[x=strlen,y=leven_iter,col sep=comma] {datasheets/itr.csv};
          \addplot table[x=strlen,y=dleven_iter,col sep=comma] {datasheets/itr.csv};
          \legend{Левенштейн, Дамерау-Левенштейн}
        \end{axis}
      \end{tikzpicture}
      \captionsetup{justification=centering}
      \caption{Сравнение времени работы итеративных алгоритмов Левенштейна и Дамерау-Левенштейна}
      \label{plt:time_cmp_l_dl}
    \end{figure}
    
    При длинах строк менее 64 символов разница по времени между итеративными реализациями незначительна, однако при увеличении длины строки алгоритм поиска расстояния Левенштейна оказывается быстрее вплоть до полутора раз. Это обосновывается тем, что у алгоритма поиска расстояния Дамерау-Левенштейна задействуется дополнительная операция, которая замедляет алгоритм.
    
    Так же сравним рекурсивную и итеративную реализации алгоритма поиска расстояния Левенштейна. Данные представлены в Таблице \ref{tab:time} и отображены на Рисунке \ref{plt:time_cmp_rec_iter}.
   
    \begin{figure}[!h!]
      \centering
      \begin{tikzpicture}
        \begin{axis}[
          axis lines=left,
          xlabel=Длина строк,
          ylabel={Время, мс},
          legend pos=north west,
          ymajorgrids=true
        ]
          \addplot table[x=strlen,y=leven_rec,col sep=comma] {datasheets/all.csv};
          \addplot table[x=strlen,y=leven_iter,col sep=comma] {datasheets/all.csv};
          \legend{Рекурсивный, Итеративный}
        \end{axis}
      \end{tikzpicture}
      \captionsetup{justification=centering}
      \caption{Сравнение времени работы итеративного и рекурсивного алгоритмов Леверштейна}
      \label{plt:time_cmp_rec_iter}
    \end{figure}
    
    \clearpage
    
    \section{Характеристики по памяти}
    
        Алгоритмы Левенштейна и Дамерау — Левенштейна не отличаются друг от друга с точки зрения использования памяти, следовательно, достаточно рассмотреть лишь разницу рекурсивной и матричной реализаций этих алгоритмов.
        
        Максимальная глубина стека вызовов при рекурсивной реализации равна сумме длин входящих строк, соответственно, максимальный расход памяти (\ref{for:99})
        \begin{equation}
        (\mathcal{C}(S_1) + \mathcal{C}(S_2)) \cdot (2 \cdot \mathcal{C}\mathrm{(string)} + 3 \cdot \mathcal{C}\mathrm{(int)}),
        \label{for:99}
        \end{equation}
        где $\mathcal{C}$ — оператор вычисления размера, $S_1$, $S_2$ — строки, $\mathrm{int}$ — целочисленный тип, $\mathrm{string}$ — строковый тип.
        
        Использование памяти при итеративной реализации теоретически равно
        \begin{equation}
        (\mathcal{C}(S_1) + 1) \cdot (\mathcal{C}(S_2) + 1) \cdot \mathcal{C}\mathrm{(int)} + 10\cdot \mathcal{C}\mathrm{(int)} + 2 \cdot \mathcal{C}\mathrm{(string)}.
        \end{equation}
        
    \section{Сравнительный анализ алгоритмов}
    
        Приведенные характеристики показывают нам, что рекурсивная реализация алгоритма очень сильно проигрывает по времени. В связи с этим, рекурсивные алгоритмы следует использовать лишь для малых размерностей строк (1-2 символа) или при малом объеме оперативной памяти.
        
        Так как во время печати очень часто возникают ошибки связанные с транспозицией букв, алгоритм поиска расстояния Дамерау – Левенштейна является наиболее предпочтительным, не смотря на то, что он проигрывает по времени и памяти алгоритму Левенштейна.
        
        По аналогии с первым абзацем можно сделать вывод о том, что рекуррентный алгоритм поиска расстояния Дамерау - Левенштейна будет более затратным по времени по сравнению с итеративной реализацией алгоритма поиска расстояния Дамерау – Левенштейна с кешированием.
    
    \section*{Вывод}
    \addcontentsline{toc}{section}{Вывод}
    
        В данном разделе было произведено сравнение количества затраченного времени и пaмяти вышеизложенных алгоритмов. Наименее затратным по времени оказался рекурсивный алгоритм нахождения расстояния Дамерау – Левенштейна.
        
        Для обработок малых длин строк (1 – 2 символа) предпочтительнее использовать рекурсивные алгоритмы, в то время как для остальных случаев рекомендуются использовать итеративные реализации. Однако, стоит учитывать дополнительные затраты по памяти, возникающие при использовании итеративных алгоритмов.