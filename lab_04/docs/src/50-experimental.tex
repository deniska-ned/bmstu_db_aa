\chapter{Экспериментальная часть}

    В данном разделе будет проведено функциональное тестирование разработанного программного обеспечения. Так же будет произведено измерение временных характеристик и характеристик по памяти каждого из реализованных алгоритмов.

    \section{Технические характеристики}
    
        Технические характеристики устройства, на котором выполнялось исследование:
        
        \begin{itemize}
            \item Процессор: Intel(R) Core(TM) i5-8250U CPU @ 1.60GHz \cite{intel}
            \item Оперативная память: 8 Gb
            \item Операционная система: Linux\cite{kernel} elementary OS 6 Odin \cite{elemos}
        \end{itemize}
    
    \section{Тестирование}
    
        Юнит тестирование проводилось при помощи фрэймворка GoogleTests\cite{gtests}. Были выполнены следующие тесты
        
        \begin{table}[]
            \centering
            \caption{Функциональные тесты}
            \begin{tabular}{|c|c|c|c|}
\hline \textbf{Строка 1} & \textbf{Строка 2} & \textbf{Последовательный} & \textbf{Параллельный}  \\
\hline &  & 0 & 0 \\
\hline Denis & Denis & 0 & 0 \\
\hline abc & bc & 1 & 1 \\
\hline bc & abc & -1 & -1 \\
\hline
            \end{tabular}
            \label{tab:my_label}
        \end{table}
        
        
        При проведении функционального тестирования, полученные результаты работы программы совпали с ожидаемыми. Таким образом, функциональное тестирование пройдено успешно.
    
    \section{Временные характеристики}
    
        Для сравнения временных характеристик проведем сравнение времени работы параллельного алгоритма для разного числа потоков, а так же сравнения последовательного и параллельного алгоритма.
        
        Данные эксперименты проведем для строк весом в 1, 2, 4, 8, 16, 32, 64 Мегабайта.
        
        Результаты замеров времени при разном количестве потоков приведены в таблице \ref{tab:time_by_th_num}.
        
        \begin{table}[]
            \centering
            \caption{Замер времени при разной длине строк и разном разном количестве потоков (время в миллисекундах)}
            \begin{tabular}{|c|c|c|c|c|c|c|c|}
\hline \multirow{2}{*}{\textbf{Вес строк, Mb}} &\multicolumn{7}{c|}{\textbf{Количество потоков, ед}} \\
\cline{2-8} &\textbf{1}&\textbf{2}&\textbf{4}&\textbf{8}&\textbf{16}&\textbf{32}&\textbf{64} \\
\hline 1&21&9&4&3&4&4&4 \\
\hline 2&33&18&14&8&7&7&8 \\
\hline 4&66&33&16&15&14&14&15 \\
\hline 8&132&66&34&29&33&30&31 \\
\hline 16&265&136&77&61&65&59&59 \\
\hline 32&536&267&151&130&127&120&118 \\
\hline 64&1055&532&266&233&241&245&236 \\
\hline 128&2117&1068&572&469&489&515&657 \\
\hline 256&4255&2134&1070&945&1159&1118&1325 \\
\hline 512&8475&4248&2751&2726&2707&2716&2695 \\
\hline
            \end{tabular}
            \label{tab:time_by_th_num}
        \end{table}
        
        Результаты замеров времени при выборе последовательного и параллельного алгоритма приведены в таблице \ref{tab:time_by_algorithm}.
        
        \begin{table}[]
            \centering
            \caption{Замер времени при разной длине строк и разных алгоритмах (время в миллисекундах)}
            \begin{tabular}{|c|c|c|}
\hline \textbf{Вес строк, Mb} & \textbf{Параллельный} & \textbf{Непараллельный} \\
\hline 1&5&22 \\
\hline 2&9&43 \\
\hline 4&21&85 \\
\hline 8&35&153 \\
\hline 16&64&285 \\
\hline 32&127&567 \\
\hline 64&283&1126 \\
\hline 128&570&2223 \\
\hline 256&1111&4419 \\
\hline 512&2342&8766 \\
\hline
            \end{tabular}
            \label{tab:time_by_algorithm}
        \end{table}
        
        
        \begin{figure}[!h]
          \centering
          \begin{tikzpicture}
            \begin{axis}[
              axis lines=left,
              xlabel={Вес строки, Mb},
              ylabel={Время, мс},
              legend pos=north west,
              ymajorgrids=true
            ]
              \addplot table[x=strsize_mb,y=parallel,col sep=comma] {datasheets/time_by_algorithm.csv};
              \addplot table[x=strsize_mb,y=nonparallel,col sep=comma] {datasheets/time_by_algorithm.csv};
              \legend{Параллельный, Последовательный}
            \end{axis}
          \end{tikzpicture}
          \captionsetup{justification=centering}
          \caption{Сравнение последовательного и параллельного алгоритма сравнения строк}
          \label{plt:time_by_algorithm}
        \end{figure}
        
        \begin{figure}[!h]
          \centering
          \begin{tikzpicture}
            \begin{axis}[
              axis lines=left,
              xlabel={Количество потоков, Mb},
              ylabel={Время, мс},
              legend pos=north west,
              ymajorgrids=true
            ]
              \addplot table[x=th_num,y=time,col sep=comma] {datasheets/time_th_num.csv};
            \end{axis}
          \end{tikzpicture}
          \captionsetup{justification=centering}
          \caption{Сравнение параллельного алгоритма при разном количестве потоков}
          \label{plt:time_th_num}
        \end{figure}
            
        На рисунке \ref{plt:time_by_algorithm} приведен график сравнения последовательного и параллельного алгоритма лексикографического сравнения строк при строка разной длины. Параллельный алгоритм использовател 8 потоков. Параллельный алгоритм работает в среднем в 4-5 раз быстрее последовательного.
        
        На рисунке \ref{plt:time_th_num} приведен график зависимости времени работы алгоритма от количества потоков для строки длины 256 Мегабайт. Наибольший выигрыш по времени происходит при количестве потоков равном 8, оно в 4.3 раза быстрее решения в 1 поток. При дальнейшем увеличении количества потоков время не уменьшается. На машине, на которой выполнялся данных эксперимент физически одновременно может выполнять 8 потоков. Следовательно, наибольший выигрыш по времени наблюдается при запуске максимального поддерживаемого процессором количества потоков, которые могут выполняться одновременно. 
    
    \section*{Вывод}
    \addcontentsline{toc}{section}{Вывод}
    
        В данном разделе было произведено сравнение количества затраченного времени и пaмяти вышеизложенных алгоритмов. 
        
        Паралельный алгоритм лексикографиеческого сравнения строк для количестве потоков равном количеству ядер процессора в среднем работает быстрее последовательного в 4-5 раз. Наибольшим выигрыш наблюдается при числе потоков равном максимальному числу потоков, которые могут физически выполнять одновременно. Дальнейнее увеличение числа потоков к росту производительности не ведет.
        